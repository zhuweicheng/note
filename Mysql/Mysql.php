<?php
/*
大而化之，通用又无用的废话。
少去字段，建立合理的索引（废话）
做人是大方点好，还是晓起点好，我认为该大方的时候就大方，女朋友要买包，此处该大方。
具体
1. 表的优化
定长与变长分离
如id int 占4个字节，char(4)占4个字符长度，也是定长
每一单元值占的字节是固定的
核心且常用的字段，宜建成定长放在一张表中
而varchar,text.blob这种变长字段，适当单独放一张表，用主键与核心表关联起来
常用字段和不常用字段相互分离
需要结合网站具体的业务来分析，分析字段的查询场景，查询额度低的字段单独拆分开来
比如用户头像，昵称，邮箱可能使用比较频繁，但是用户其它信息，只有点击个人主页或者少量场景才会去取，就可以拆出来放入不常用表中
在1对多，需要关联统计的字段增加冗余字段
比如每个版块都需要统计新发帖，已有帖子总数的字段，只需要将该统计字段添加都板块表中即可，每次新增时都对其进行递增，查询时无需再统计具体的表
目前程序的优化，其实无非就是两种：空间换时间、时间换空间
2. 列选择原则
字段类型优先级
整形>date，time>enum，char>varchar>text，blob
列的特点分析
整形：定长，没有国家，地区之分，没有字符集差异
比如tinyint(1) 1,2,3,4,5 <-> char(1) a,b,c,d,e
从空间上都是占用1个字节，但是order by 排序，整形快
原因：字符类型需要考虑字符集和校对集（即是排序规则）
time定长，运算快，节省时间，考虑时区，sql书写时不方便表达 where >= '2017-08-17'这样的表达式，需要借助函数或者稍作转化
enum能起约束值的目的，内部用整形来存储，但与char联查时，内部要经历串与值的转化
char 定长，考虑字符集和排序校对集
varchar不定长，要考虑字符集转换和排序校对集，速度慢
text/blob无法使用内存临时表等操作，只能在磁盘上进行排序等
比如性别，utf-8为例
char(1) 3个字节长度
enum('男', '女') 内部转成数字来存储，多了一个转换过程
tinyint(1) 0，1，2 定长1个字节
够用就行，不要慷慨，比如smallint,varchar(N)
原因：大的字段消耗内存，影响速度
以年龄为例，tinyint() unsigned not null 可以存储最大255岁，用int浪费了三个字节
以varchar(10),varchar(300)存储的内容相同，但在表联查时要浪费更难多内存
尽量避免使用NULL
null不利于索引，要用特殊的字节来标注
在磁盘上占据空间其实更大，mysql5.7里关于null已经做了优化，大小区别不明显
null也不便于查询，需要用单独的is null等子句
3. 索引优化
索引是一种高效查询的数据结构。索引提高查询，排序，分组速度。
b-tree索引
大的方面看，都用的平衡树，但具体的实现上，各引擎稍有不同，myisam,innodb默认使用b-trr索引 
但抽象一下，B-tree树系统可理解为排好序的快速查找结构
hash索引
memory表使用hash索引，查询速度更快，理论复杂度O(1)
既然哈希查找速度快，为什么不用哈希索引？
hash计算的结果是随机的，在磁盘上随机放置，地址可能有冲突，拉链算法，磁盘会有很多空洞
无法对范围查询进行优化
无法利用前缀索引，因为哈希操作后前缀可能差别很大
排序也无法优化
必须回行，就是说，通过索引拿到数据位置，必须回到表中取数
b-tree索引常见误区
在where条件上常用的列都加上索引
例如where cat_id=3 and price > 100
错误：在cat_id和price上都加上索引
这样只能用上cat_id或price索引，因为独立的索引，同时只能用一个，实际使用中，更多的是联合索引，比如建立cat_price(cat_id, price)联合索引
在多列上建立索引后，查询那个列索引都将发生作用
多列索引上索引发生作用需要满足左前缀要求
index(a,b,c)
where a=3 只用a索引
where a=3 and b=4 使用了a,b索引
where a=3 and b=4 and c=5 使用了a,b,c索引
where b=3 / where c=4 无法使用索引
where a=3 and c=4 是能使用a索引
必须按顺序使用，否则不能使用索引
左前缀原则
聚族索引和非聚簇索引
myisam 非聚族索引 一次索引和次级索引都指向磁盘上的位置
innodb 聚族索引 树上保存信息，不需要回行，即根据地址在此查找数据，次级索引指向对主键的引用，但是不规则数据会造成页分裂。
索引覆盖
如果查询的列刚好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行在磁盘上找数据，这种查询速度非常快。
理想的索引
查询频繁，
区分度高，100万用户，性别区分度不高
长度小，索引长度直接影响索引文件的大小，影响增删改的速度和查询速度，合理使用左前缀
尽量能覆盖常用查询字段
针对列中的值，从左往右截取部分来建索引
截的越短，重复读越高，区分度越小，索引效果越不好
截的越长，重复度低，区分度高，索引效果越好，但带来的影响也越大，增删改变慢并影响查询速度
比如单词word，从左往右截取
(select count(distinct left(word, 1)) from dict) / (select count(*) from dict)
即是计算做前缀去重后的条数与总条数的差异，找到趋于平衡的位置，就选择该处建立做前缀索引
对于一般的系统应用，区别度能达到0.1索引的性能就可以接受
对于做前缀不易区分的列，建立索引的技巧
比如url列
https://www.baidu.com
http://www.zixue.it
列的前面字符几乎是一样的，可以用一下两个办法来解决
倒叙存取数据，区分度相对较大
比如网址，因为前面基本相同，com,cn,net,me等
伪哈希技巧
crc32(str)函数计算一个字符串的 crc32 多项式，能把字符串转为32位整数，一种哈希算法
然后给这个整形加索引,查询时也按该方法转化
数据也可能会有重复，但这是值得的，索引长度为int4个字节
多列索引
列的查询频率，区分度，结合具体的业务来查找出最好的索引
索引与排序
排序可能发生2种情况
对于覆盖索引，直接在索引上索引时，就是有顺序的
在innodb引擎中，沿着索引字段排序，也是自然有序的；
对于myisam引擎，如果按某索引字段排序，如id，但取出的字段中，有未索引字段，则需要回行，在排序
先取出数据，形成临时表做filesort文件排序，但文件可能在磁盘上也可能在内存中
我们要争取 取出来的数据本身就是有序的，用索引来排序
重复索引
在同一个列，或者顺序相同的几个列，建立了多个索引
重复索引没有任何帮助，只会增大索引文件，拖慢更新速度，去掉
冗余索引2个索引所覆盖的列有重叠
顺序不一样
索引碎片和维护
在长期的数据更改过程中，索引文件和数据文件，都将产生空洞，形成碎片，我们可以通过一个
nop操作（不产生对数据实质影响的操作）来修改表
比如表引擎innodb，可以alter table xxx engine innodb
optimize table 表名，也可以修复
修复表的数据及索引碎片，就会把所有的数据文件重新整理一遍，使之对齐
这个过程，如果表的行数比较大，也是非常耗时的操作，所以不能频繁修复
如果表的update操作很频繁，可以按周，按月来修复
如果不频繁，可以更长的周期来做修复
查询大原则
sql的时间花在哪里
等待，执行时间
这两个时间并非孤立的，如果单条语句执行快了，对其它语句的锁定也就少了
其它语句受到干扰，关键在执行上
执行时间耗费
查找，沿着索引查找，慢者可能拖慢全表扫描
取出，查到行后，把数据取出来
如何查找快
联合索引
索引覆盖
传输少，更少的行和列
切分查询，按数据拆成多次
分解查询，按逻辑把多个表连接查询分成多个简单sql
sql语句优化思路
不查，通过业务逻辑来计算，比如观察长期的数据变化，论坛会员注册数，适当增加，而不需要精确计算数据库中的值
少查，尽量精准的查，少取行，一般一次性取10-30条左右，高效的查
必须要查，尽量从索引上查，取时，少取行和列
*/
